网络安全
===

文件上传漏洞
---

文件上传漏洞顾名思义，就是在上传文件的时候，攻击者利用 开发人员没有对上传文件进行检测或者检测逻辑不全面的漏洞，上传了一个可执行文件（如木马，病毒，恶意脚本）到服务器执行，并最终获得网站控制权限的高危漏洞。

**常见的上传文件校验方式**：

1. 客户端校验：在前端使用js对==文件后缀名进行检测==。

   > 破解方法：
   >
   > 1. 直接在浏览器禁用Javascript。
   >
   > 2. 先改成允许上传的文件类型，然后用Burpsuite改成脚本文件类型，即可绕过。

2. 服务端 content-type校验：==指定content-type字段类型==，如果文件不是指定类型就返回错误。

   > 破解方法：可以通过抓包，将content-type字段改为服务端允许的类型。

3. 服务端 文件后缀名检测：通过自己写==正则匹配文件后缀名==，判断其是否符合要求

   > 破解方法：
   >
   > 1. 文件名大小写可能可以破解，例如Php，AsP等类似的文件名
   > 2. 00截断。例如：/123.php%00.jpg/123.jpg -> /123.php。因为%00是空字符，字符串对于空字符后面的字符不进行处理。

**防护方法**：

1. 文件上传的目录设置为不可执行。
2. 上传文件重命名。
3. 隐藏上传文件的路径。



SQL注入
---

SQL注入就是利用一些查询语句的漏洞，将SQL语句传递到服务器解析并执行的一种攻击手段。

**危害**：

1. 绕过网页或Web应用程序的身份验证和授权
2. 修改和删除数据库中的记录

**常见sql注入场景**：

原理：用户进行用户名和密码验证时，网站需要查询数据库。查询数据库就是执行SQL语句，但在查询过程中，并未对一些特殊符号进行过滤，如单引号(')。

（1）用户登录时，后台执行的数据库执行的SQL语句是：`Select * From users Where user_id='用户名' And password='密码'` 

（2）由于网站后台在进行数据库查询的时候没有对单引号进行过滤，当输入用户名【admin】和万能密码【`1' or' 1=1`】时，执行的SQL语句变为：`Select * From users Where user_id='admin' And password='1' or '1=1'` 

（3）由于SQL语句中逻辑运算符具有优先级，`=`优先于`and`，`and`优先于`or`，且适用传递性。因此，SQL语句的查询结果为TRUE，就意味着认证成功，也可以登录到系统中。

或者狠一点，把表都删了：`Select * From users Where user_id='admin' And password='1' or '1=1; drop table users'` 

**应对方法**：

1. 使用PreparedStatement。



XSS
---

XSS（Cross Site Script） 跨站脚本漏洞，就是攻击者在 Web 页面中插入恶意脚本，当用户浏览页面时，促使脚本执行，从而达到攻击目的。利用的是用户对网站的信任。

XSS 主要有三种类型：

- **非持久性型 XSS**：受害者被引诱点击一个带有恶意脚本代码参数的 URL，当 URL 地址被打开时，恶意代码参数被 HTML 解析、执行。比如用户被引诱点击了链接 `www.abc.com?name='<script src='www.abc.com/a.php'></scirpt>'` 之后，会访问a.php脚本。

  > 预防：前端渲染的时候对任何的字段都需要做 escape 转义。

- **持久型 XSS**： 注入的脚本永久的存在于目标服务器上，每个受害者向服务器请求此数据时都会唤醒攻击脚本；一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等。

  > 预防：后端在入库前/前端发起请求前 将所有的数据统一进行转义处理，或去除特殊标签。



CSRF
---

CSRF（Cross-site request forgery）跨站请求伪造。攻击者利用网站对用户的信任，跨站点向网站 发起一些伪造的用户操作请求，以达到攻击的目的。例如用户登录了网站A，此时浏览器中产生了A网站的cookie，在此期间点击了攻击者发的图片，图片中携带着恶意代码，让攻击者可以伪造成用户向网站A发起请求（请求会自动携带cookie信息）。

预防措施：

1. 请求头中携带验证信息，比如token或验证码。token可以放在浏览器中。

> 为什么token可以防止csrf，而cookie不可以？
>
> 因为cookie一般保留sessionId来识别用户身份，而浏览器每次发起请求时都会自动携带cookie，因此可以攻击者很轻松的伪造身份。但是token一般存放在浏览器的localstorage或sessionstorage 中，只有由api发起的请求才会携带token字段。



DDOS攻击
---

DDOS攻击全称为：分布式拒绝服务攻击，是指攻击者利用大量“肉鸡”对目标服务器发动大量的正常或非正常请求、耗尽目标主机资源或网络资源，从而使被攻击的主机不能为合法用户提供服务。

该攻击防御的难点在于**区分真实客户流量与攻击流量**。



### 应用层攻击：HTTP洪水

http洪水：**大量的 HTTP 请求**涌向服务器，导致服务器奔溃。这些HTTP请求可以使用随机 referrer 和用户代理，来绕过黑名单。

==攻击目标是服务器==。

防御手段：使用web防火墙(WAF)、如果IP地址有规律，则屏蔽所有符合此规律的IP的请求，宁可错杀也不放过。



### 应用层攻击：CC挑战黑洞

CC(ChallengeCollapsar，挑战黑洞)，使用代理服务器向目标服务器发送大量貌似合法的请求，而这些请求都是在请求大量的数据，造成服务器资源的浪费，**CPU长时间处于高频率状态**。

==攻击目标是服务器==。

防御手段：web防火墙、使用缓存来减少服务器压力。



### 传输层攻击：Syn攻击

原理：

在TCP三次握手过程中，服务器维护了一个**未连接队列**，该队列为每个客户端的syn包都创建了一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，将该条目移到**全连接队列中**，服务器进入ESTABLISHED状态。（==如果全连接队列的长度满了，则可能出现丢包的情况==）

- 每个条目都有指定的存活时间。

- 未连接队列的长度有限制。
- 超时时间每次不同，重传次数有限制。

***

Syn攻击是指 攻击者伪造IP地址对服务器发起SYN请求，即**只发送syn包**，服务器收到之后回应一个确认报文，而真实的IP会认为，我没有发送请求，不作回应。服务器没有收到回应，会重试3-5次并且等待一个SYN Time（一般30秒-2分钟）后，丢弃这个连接。

如果攻击者大量发送这种伪造地址的SYN请求，服务器端将会消耗非常多的资源来处理这种半连接。

==攻击目标是网络设备==。

**检测SYN攻击**：当你在服务器看到大量的半连接状态时，尤其是IP地址随机的，基本上可以断定是一次syn攻击。在linux上可以使用netstat命令查看半连接状态 `netstat -ant |grep SYN_RECV` 

**防御手段**：

- 缩短超时时间
- Syn cookies技术
- 过滤网关防护

